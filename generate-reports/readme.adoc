:toc: left
:imagesdir: includes
= Generate Reports About Structures
Dirk Mahler <dirk.mahler@jqassistant.org>

:numbered:

[.lead]
// tag::lead[]
This tutorial is about generating different types of reports and convert them to human-readable reports. In this tutorial we create full on documents including rules with their embedded result tables, diagrams or CSV files.
// end::lead[]

NOTE: This tutorial is written for version 2.0.4 of jQAssistant.

== Overview

Rules (i.e. concepts, constraints and groups) are written in xml files. When executing, jQAssistant produces a jqassistant-report.xml file which reflects the analysis results. You can then use Asciidoctorj in combination with the `jqassistant-asciidoctorj-extensions` extension to transform this xml file to readable html, pdf, confluence or any other file type supported by Asciidoctorj.

=== Report type options

When writing the rules, you have the option to specify different report types to visualize the results of your rules. These are:

`<<component-diagrams,plantuml-component-diagram>>`::
  Nodes and relationships of the result are converted to a PlantUML component diagram and rendered to an SVG file.
`<<class-diagrams,plantuml-class-diagram>>`::
  Nodes representing Java packages, classes, fields or members and their connecting relations are converted
  to a PlantUML class diagram which is rendered to an SVG file.
`<<sequence-diagrams,plantuml-sequence-diagram>>`::
  Path structures of the result are converted to a PlantUML sequence diagrams which is rendered to an SVG file.

Furthermore a report type may be chosen for creating a file of a dedicated format which then will be shown as link:

`<<graphml,graphml>>`::
  Similar to the `plantuml-component-diagram` nodes and relationships are converted to a GraphML file.
  This may be viewed and explored using http://www.yworks.com/en/products/yfiles/yed/[yEd].
`csv`::
  Create a CSV file containing tabular data for further analysis in other tools. There is no section about this type in the tutorial, but it is generally very similar to the example in the <<Tables>> section (the only difference being, that the results are put into a csv).

WARNING: For some of these export types, you may need some extra plugins. Refer to the <<Adding jQAssistant plugins>> section for details.

WARNING: The next step (<<Result rendering>>) is required if you want to convert the jqassistant-report.xml file to a human-readable format. Rendering the results also embeds all generated Diagrams and attachments created by jQAssistant.

=== Result rendering

When writing your documentation, you have the option to use the following include directives:

`<<Rendering summaries, include::jQAssistant:Summary[]>>`::
renders a summary table with the rules from the project.

`<<Rendering rules, include::jQAssistant:Rules[]>>`::
renders the rules from the project with detailed information for each rule.

=== Project structure

For this tutorial the following project structure is going to be used:

[source,raw]
----
your.project      <1>
your.project.a    <2>
your.project.b
your.project.c
----

<1> The root package of the project is `your.project`.
<2> A package located directly within the root package represents a `Module`.
The project consists of the modules `a`, `b` and `c` where `b` and `c` contain Java types depending on types located in `a`.

== Integrate required dependencies into the project

The tutorial uses https://maven.apache.org[Apache Maven] for building the project.

=== Adding jQAssistant

jQAssistant is enabled by adding the plugin to the `build/plugins` section of the file `link:pom.xml[pom.xml]`:

[source,xml]
.pom.xml enabling jQAssistant
----
include::pom.xml[tag=jQAplugin,indent=0]
----

=== Adding jQAssistant plugins

To render your reports as diagrams or graphs you need to add some plugins to jQAssistant. Also you need to add the `link:.jqassistant.yml[.jqassistant.yml]`:

[source, yaml]
.jqassistant.yml
....
include::.jqassistant.yml[]
....
<1> This plugin is needed to use the report types `plantuml-component-diagram`, `plantuml-class-diagram` and `plantuml-sequence-diagram`
<2> This plugin is needed to use the report type `graphml`
<3> This line tells jQAssistant to apply the group (groups are rules that combine several sub-rules like other groups, concepts and constraints) `Default`, which is defined in `link:jqassistant/default.xml[default.xml]`.

TIP: To verify the setup, a build can be triggered using `mvn verify`.
The build should succeed and show a console output containing jQAssistant's scan and analysis messages.

=== Adding Asciidoctor

To render the reports as human-readable files we need to implement Asciidoctor into our project. In our example we use the `asciidoctor-maven-plugin`. We also need to add the `jqassistant-asciidoctorj-extensions` to Asciidoctor. This is needed later to process and include the results generated by jQAssistant. The following snippet also stems from the `build/plugins` part of the `link:pom.xml[pom.xml]`:

[source,xml]
.pom.xml enabling Asciidoctor
----
include::pom.xml[tag=Asciidocplugin,indent=0]
----
<1> defines the file type for our reports
<2> defines that Asciidoctor preserves the folder structure we created inside our `src/docs/asciidoc` directory
<3> defines where jQAssistant puts the jqassistant-report.xml (normally you do not have to change this attribute, because jQAssistant puts the file in the already specified location)
<4> defines where the `jqassistant-asciidoctorj-extensions` copies the images referenced by the `jqassistant-report.xml` to (the path is relative to the export path; the export-path defaults to `target/generated-docs`)
<5> includes the aforementioned `jqassistant-asciidoctorj-extensions` into the Asciidoctor chain

TIP: If you want to know more about the `asciidoctor-maven-plugin` and the available configuration attributes check the https://docs.asciidoctor.org/maven-tools/latest/plugin/goals/process-asciidoc/#configuration[Asciidoctor Maven plugin Documentation] or the https://github.com/asciidoctor/asciidoctor-maven-plugin#examples[Github page] for some helpful examples.

== Writing rules

=== Where are the rules located?

All rules are written as xml file which are located in the folder `jqassistant/`:

[source,raw]
-----
jqassistant/default.xml    <1>
jqassistant/module.xml     <2>
-----
<1> link:jqassistant/default.xml[default.xml]: This file defines a top level group that (recursively) includes the rules from module.xml
<2> link:jqassistant/module.xml[module.xml]: This file defines rules that generate reports about the project's module structure as tables, diagrams and GraphML files.

=== Rule-report types

In the following sections the different report types for rules will be explained. The rules are processed by jQAssistant and the results are placed inside the `jqassistant-report.xml` (in case of rendered diagrams or attachments, the files are placed inside the `target/jqassistant/report` directory and are only referenced in the `jqassistant-report.xml`).

In the following sections, all depicted pictures are generated by applying the steps from the <<Integration_with_Asciidoc>> section. Without this step, the results are not rendered as human-readable files.

==== Tables

The file `link:jqassistant/module.xml[module.xml]` defines concepts related to the module structure of the project and for generating reports in different representations.

A concept `module:Module` first adds a label `Module` to each child package of the root package `your.project`:

[source,xml]
....
include::jqassistant/module.xml[tags=moduleModule]
....

The returned result defines two columns `Module` (the name of the module) and `Package`.
As no report type is specified for this concept its result would be rendered to a table containing these columns:

image::module_table.png[Resultset]

NOTE: The table is not saved as a file. Instead, this tables structure is stored directly in the xml. To render it to a readable format, check the <<Integration_with_Asciidoc>> section.

TIP: If you want to export and embed this result table as a csv file, you may set `<report type=csv>`. In the next section you can see, where to place this attribute.

[[component-diagrams]]
==== Component Diagrams
The concept `module:Dependencies` which is based on `module:Module` aggregates the type dependencies to the module packages:

[source,xml]
....
include::jqassistant/module.xml[tags=moduleDependencies]
....

This concept returns the modules (module1, module2) and their dependency relations (dependsOn).
The result is used for generating a component diagram by setting the `reportType` attribute to `plantuml-component-diagram`.

image::module_component_diagram.png[]

TIP: The generated .plantuml and .svg files are located in the folder `target/jqassistant/report/plantuml`.

[[graphml]]
==== GraphML Files

If diagrams become more complex it may be useful to export them as GraphML documents:

[source,xml]
....
include::jqassistant/module.xml[tags=moduleDependenciesGraphML]
....

To create a graphml we are setting the `report type` to `graphml` as illustrated above.

The HTML document will provide a link to the GraphML file:

image::module_graphml_report_link.png[Resultset]

TIP: The generated .graphml files are located in the folder `target/jqassistant/report/graphml`.
They may be viewed using http://www.yworks.com/en/products/yfiles/yed/[yEd].
After opening a file you need to apply a layout, Layout->Hierarchical (Alt-Shift-H).

//image::module_graphml_yed.png[]

By extending the result structure the GraphML reports may be used to allow an interactive drill-down from module to type level:

[source,xml]
....
include::jqassistant/module.xml[tags=moduleDependenciesGraphMLDrilldown]
....

This concept returns a graph for each module which is rendered as `parent` containing types (`nodes`) and dependencies (`relationships`) per module.
The generated GraphML report file can be interactively explored in http://www.yworks.com/en/products/yfiles/yed/[yEd] by expanding (`+`) or collapsing (`-`) module nodes and applying the horizontal layout:

//image::module_graphml_drilldown_yed.png[]

[[class-diagrams]]
==== Class Diagrams

Java structures returned by a rule may be rendered to class diagrams.
The following elements are supported:

* Packages (`:Java:Package`)
* Types (`:Java:Type`)
* Members (`:Java:Member`, `:Java:Field`, `:Java:Method`)
* Inheritance relations between types (`:EXTENDS`, `:IMPLEMENTS`)
* any other relations between types (rendered as associations)

The concept `module:ClassDiagram` returns all types including their optional fields and methods:

[source,xml]
....
include::jqassistant/module.xml[tags=moduleClassDiagram]
....

As the `report type` is set to `plantuml-class-diagram`, the following diagram is rendered:

image::module_class_diagram.png[]

[[sequence-diagrams]]
==== Sequence Diagrams

The concept `module:SequenceDiagram` returns a path structure with a column named `sequence`. When there is such a column, the report can be rendered as a sequence diagram:

[source,xml]
....
include::jqassistant/module.xml[tags=moduleSequenceDiagram]
....

As the report type is set to `plantuml-sequence-diagram`, the following diagram is rendered:

image::module_sequence_diagram.png[]


In this diagram the nodes of the sequence are interpreted as participants and the relationships between them as messages.

[[Integration_with_Asciidoc]]
== Integration with Asciidoc

In this tutorial there are two files that will be rendered by Asciidoctor. The sources of both files are located in the `src/docs/asciidoc/modules` directory. This is the default location the `asciidoctor-maven-plugin` looks for files to render in. The rendered files are then stored in the `target/generated-docs` directory (also the default).

TIP: Check the https://github.com/asciidoctor/asciidoctor-maven-plugin[asciidoctor-maven-plugin Github page] for more information on how to change these default values.

In our example the link:src/docs/asciidoc/index.adoc[index.adoc] represents the root file. It includes the link:src/docs/asciidoc/modules/module.adoc[module.adoc] with the following line:

....
\include::modules/module.adoc[leveloffset=+1]
....

TIP: The `leveloffset` attribute is responsible for offsetting each heading from the link:src/docs/asciidoc/modules/module.adoc[module.adoc] by the given number. Refer to https://docs.asciidoctor.org/asciidoc/latest/directives/include/#include-syntax[include directive Asciidoctor]

=== Rendering summaries

To render a summary of our jQAssistant reports within an adoc file, we use:

[source,adoc]
....
\include::jQAssistant:Summary[]
....

This syntax is used in the link:src/docs/asciidoc/index.adoc[index.adoc].

NOTE: The summary table will be displayed in the index.html inside the `target/generated-docs` directory after you executed your maven build (`mvn verify`).

In our case the summary table looks like this:

.Summary table
image:summary_table.png[]

=== Rendering rules

To render a rules with their respective results within an adoc file, we use:

[source,adoc]
....
\include::jQAssistant:Rules[]
....

This syntax is used in the link:src/docs/asciidoc/modules/module.adoc[module.adoc].

NOTE: In the link:src/docs/asciidoc/modules/module.adoc[module.adoc] some attributes are used inside the [] brackets. Refer to the next section (<<Using filters>>) for an overview.

In our case a result (with some additional attributes in the [] brackets: [concepts="module:Dependencies", leveloffset=+2]), looks like this:

.Rule with filter concepts="module:Dependencies"
image:module_component_diagram.png[]

=== Using filters

When using the two include directives mentioned above, you have the possibility to filter your rules by their id's. You have a filter for `concepts` and a filter for `constraints`. In this tutorial we use these filters like this:

....
\include::jQAssistant:Summary[concepts="module:*"] <1>
\include::jQAssistant:Rules[concepts="module:Module", leveloffset=+2] <2>
....

<1> produces a summary table that contains all concepts starting with `module:` (if it exists). Constraints would not be rendered in this case (even if there were any defined).
<2> produces an overview of the concept results for the concept module:Module. The leveloffset attribute shifts all headings within the include by 2. This way, the headings are in their level all below the headings already used.

You may also use these ways of filtering like this:

....
\include::jQAssistant:Summary[concepts="jQA:my:specific:concept-id", constraints="*"]
....
This would result in a summary table containing the concept with the name jQA:my:specific:concept-id. Also, all constraints will be displayed.

TIP: To learn more about filtering refer to https://github.com/jqassistant-tooling/jqassistant-asciidoctorj-extensions#create-your-report[jqassistant-asciidoctorj-extensions]

== Resources

1. https://maven.apache.org[Apache Maven]
2. https://jqassistant.github.io/jqassistant/doc/2.0.0/manual[jQAssistant manual]
3. https://docs.asciidoctor.org/maven-tools/latest/plugin/goals/process-asciidoc/#configuration[Asciidoctor Maven plugin Documentation]
4. https://github.com/asciidoctor/asciidoctor-maven-plugin[Asciidoctor Maven plugin Github]
5. https://github.com/jqassistant-tooling/jqassistant-asciidoctorj-extensions[jqassistant-asciidoctorj-extensions]
6. http://www.yworks.com/en/products/yfiles/yed/[yEd]



